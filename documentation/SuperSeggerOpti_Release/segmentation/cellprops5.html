<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of cellprops5</title>
  <meta name="keywords" content="cellprops5">
  <meta name="description" content="cellprops Calculates the shape properties of the region or 'cell'">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">SuperSeggerOpti_Release</a> &gt; <a href="index.html">segmentation</a> &gt; cellprops5.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for SuperSeggerOpti_Release/segmentation&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>cellprops5
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>cellprops Calculates the shape properties of the region or 'cell'</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function info = cellprops5( mask, props ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> cellprops Calculates the shape properties of the region or 'cell'

 INPUT :
       mask : cell / region mask
       props : proper generated by regionprops
 OUTPUT :
         info = [L1
             L2mean,
             Lneck,
             L2max,
             L2v,
             s1,
             s2,
             s3,
             RoundIndOver,
             RoundIndUnder,
             props.Area,
             stm1,
             sa1,
             sa2,
             sa3,
             sa4,
             1/L1,
             1/L2mean,
             minWidthEnd,
             sqmin,
             sqmax];

 Copyright (C) 2016 Wiggins Lab
 University of Washington, 2016
 This file is part of SuperSeggerOpti.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function tmp = norm2( dd )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function info = cellprops5( mask, props )</a>
0002 <span class="comment">% cellprops Calculates the shape properties of the region or 'cell'</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% INPUT :</span>
0005 <span class="comment">%       mask : cell / region mask</span>
0006 <span class="comment">%       props : proper generated by regionprops</span>
0007 <span class="comment">% OUTPUT :</span>
0008 <span class="comment">%         info = [L1</span>
0009 <span class="comment">%             L2mean,</span>
0010 <span class="comment">%             Lneck,</span>
0011 <span class="comment">%             L2max,</span>
0012 <span class="comment">%             L2v,</span>
0013 <span class="comment">%             s1,</span>
0014 <span class="comment">%             s2,</span>
0015 <span class="comment">%             s3,</span>
0016 <span class="comment">%             RoundIndOver,</span>
0017 <span class="comment">%             RoundIndUnder,</span>
0018 <span class="comment">%             props.Area,</span>
0019 <span class="comment">%             stm1,</span>
0020 <span class="comment">%             sa1,</span>
0021 <span class="comment">%             sa2,</span>
0022 <span class="comment">%             sa3,</span>
0023 <span class="comment">%             sa4,</span>
0024 <span class="comment">%             1/L1,</span>
0025 <span class="comment">%             1/L2mean,</span>
0026 <span class="comment">%             minWidthEnd,</span>
0027 <span class="comment">%             sqmin,</span>
0028 <span class="comment">%             sqmax];</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Copyright (C) 2016 Wiggins Lab</span>
0031 <span class="comment">% University of Washington, 2016</span>
0032 <span class="comment">% This file is part of SuperSeggerOpti.</span>
0033 
0034 debug = false;
0035 
0036 <span class="comment">% Calculate cell thickness and length by rotating the</span>
0037 <span class="comment">% region based on the angle of the majorAxis.</span>
0038 Orientation = props.Orientation;
0039 
0040 imRot = (fast_rotate_loose_double( mask, -Orientation+90 ));
0041 ss = size(imRot);
0042 
0043 <span class="keyword">if</span> debug
0044     figure(2);
0045     clf;
0046     imshow(cat(3,ag(imRot)+0.5*ag(~imRot),ag(imRot),ag(imRot)),<span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
0047     hold on;
0048 <span class="keyword">end</span>
0049 
0050 width       = sum(double(imRot),2);
0051 ymask       = (width&gt;=1);
0052 widthWindow = ([0;width(1:end-1)] + width + [width(2:end);0] )/3;
0053 
0054 L1          = sum(ymask);
0055 L2max       = max(widthWindow);
0056 L2v         = var(widthWindow);
0057 
0058 ymin = find(ymask,1,<span class="string">'first'</span>);
0059 ymax = find(ymask,1,<span class="string">'last'</span>);
0060 
0061 
0062 ind = (ymin):(ymax);
0063 L2mean = mean(width(ind));
0064 <span class="keyword">if</span> L2mean&lt;1
0065     L2mean=1;
0066 <span class="keyword">end</span>
0067 
0068 <span class="comment">% Sine Cosine Idea</span>
0069 nn = (numel(ind)-1);
0070 s  = 2*pi*(0:nn)/nn;
0071 
0072 s1 = mean(width(ind)'.*sin(s*0.5));
0073 s2 = mean(width(ind)'.*sin(s));
0074 s3 = mean(width(ind)'.*sin(s*1.5));
0075 
0076 
0077 <span class="comment">% Calculate the neck width</span>
0078 <span class="keyword">if</span> numel(widthWindow) &gt; 6;
0079     ww       = widthWindow';
0080     v        = ww(3:end)-ww(1:end-2);
0081     s_change = logical([0, sign(v(2:end))-sign(v(1:end-1)),0,0]);
0082     s_change(2:end) = logical(s_change(2:end)+s_change(1:end-1));
0083     ind = find(s_change);
0084     ind_ = ind(logical((ind&gt;3).*(ind&lt;(numel(ww)-2))));
0085     
0086     <span class="keyword">if</span> isempty(ind_)
0087         Lneck = L2mean;
0088         pos = mean([ymin,ymax]);
0089     <span class="keyword">else</span>
0090         [Lneck,pos] = min( ww(ind_) );
0091         pos = ind_(pos);
0092     <span class="keyword">end</span>
0093 <span class="keyword">else</span>
0094     Lneck = L2mean;
0095     pos = mean([ymin,ymax]);
0096 <span class="keyword">end</span>
0097 
0098 <span class="keyword">if</span> Lneck &gt; L2mean
0099     Lneck = L2mean;
0100     pos = mean([ymin,ymax]);
0101 <span class="keyword">end</span>
0102 
0103 <span class="keyword">if</span> debug
0104     xx = 1:numel(ww);
0105     
0106     figure(1);
0107     clf;
0108     plot( xx, ww, <span class="string">'.-'</span> );
0109     hold on;
0110     plot( pos+0*x,x, <span class="string">'r:'</span> );
0111     plot( xx(ind_), ww(ind_), <span class="string">'g.'</span> );
0112     figure(2)
0113 <span class="keyword">end</span>
0114 
0115 
0116 
0117 <span class="comment">% make stuff w/o rotating</span>
0118 <span class="keyword">if</span> abs(tan( props.Orientation*pi/180 )) &gt; 1
0119     yunr = sum(mask,2)';
0120 <span class="keyword">else</span>
0121     yunr = sum(mask);
0122 <span class="keyword">end</span>
0123 
0124 ip = find( logical(yunr), 1, <span class="string">'last'</span> );
0125 im = find( logical(yunr), 1, <span class="string">'first'</span> );
0126 
0127 
0128 <span class="comment">% thin ends</span>
0129 im = find( logical(yunr), 1, <span class="string">'first'</span> );
0130 ip = find( logical(yunr), 1, <span class="string">'last'</span> );
0131 
0132 <span class="keyword">if</span> ip-im &gt;= 3
0133     m1 = mean( yunr(im+[ 0, 1]) );
0134     m4 = mean( yunr(ip+[-1, 0]) );
0135     minWidthEnd = min(m1,m4);
0136 <span class="keyword">else</span>
0137     minWidthEnd = L2mean;
0138 <span class="keyword">end</span>
0139 
0140 
0141 
0142 <span class="comment">% Square ends</span>
0143 <span class="keyword">if</span> ip-im &gt;= 7
0144     m2 = mean( yunr(im+[ 2, 3]) );
0145     m3 = mean( yunr(ip+[-3,-2]) );
0146     
0147     sq1 = m2-m1;
0148     sq2 = m3-m4;
0149     
0150     sqmax = max(sq1,sq2);
0151     sqmin = min(sq1,sq2);
0152 <span class="keyword">else</span>
0153     sqmax = 0;
0154     sqmin = 0;
0155 <span class="keyword">end</span>
0156 
0157 
0158 
0159 <span class="comment">% Calculate the maximum bend angle.</span>
0160 dr  = 3;
0161 dr2 = 3;
0162 yy = (ymin+dr):dr2:(ymax-dr);
0163 
0164 <span class="keyword">if</span> numel(yy) &gt; 4
0165     tmp = imRot(yy,:);
0166     
0167     x = 1:ss(2);
0168     
0169     
0170     [X,Y] = meshgrid(x,yy);
0171     
0172     xx = sum( X.*tmp,2 )./sum(tmp,2);
0173     
0174     d1 = [xx(1:end-2)-xx(3:end),yy(1:end-2)'-yy(3:end)'];
0175     
0176     dangle = ((d1(1:end-2,1).*d1(3:<span class="keyword">end</span>,2)<span class="keyword">...</span>
0177         -d1(1:end-2,2).*d1(3:<span class="keyword">end</span>,1))./<span class="keyword">...</span>
0178         (<a href="#_sub1" class="code" title="subfunction tmp = norm2( dd )">norm2</a>(d1(1:end-2,:)).*<a href="#_sub1" class="code" title="subfunction tmp = norm2( dd )">norm2</a>(d1(3:<span class="keyword">end</span>,:))));
0179     
0180     
0181     stm1 = max( dangle.^2 );
0182     
0183     
0184     angle = cumsum(dangle)';
0185     na = numel(angle)-1;
0186     
0187     s = (0:na)/na*pi/2;
0188     
0189     <span class="keyword">try</span>
0190         sa1 = mean( angle.*sin(s  ) );
0191         sa2 = mean( angle.*sin(s*2) );
0192         sa3 = mean( angle.*sin(s*3) );
0193         sa4 = mean( angle.*sin(s*4) );
0194     <span class="keyword">catch</span> ME
0195         printError(ME)
0196     <span class="keyword">end</span>
0197     
0198     
0199     <span class="keyword">if</span> debug
0200         ss_ = size(d1);
0201         <span class="keyword">for</span> ii = 1:ss_(1)
0202             plot( xx(ii)+[0,-d1(ii,1)], yy(ii)+[0,-d1(ii,2)], <span class="string">'c.'</span> );
0203         <span class="keyword">end</span>
0204     <span class="keyword">end</span>
0205     
0206     
0207     <span class="comment">% Calculate the end score</span>
0208     yy = [(ymin+dr),(ymax-dr)];
0209     xx = widthWindow(round(yy));
0210     r = ((xx)/2);
0211     r(r&lt;1)=1;
0212     
0213     yyd = [(ymin+r(1)+[-1,0,1]),(ymax-r(2)+[-1,0,1])];
0214     yy  = round(yyd);
0215     
0216     [X] = meshgrid(x,yy);
0217     
0218     tmp = imRot(yy,:);
0219     xx = sum( X.*tmp,2 )./sum(tmp,2);
0220     xx = [mean(xx(1:3)),mean(xx(4:6))];
0221     yyd = yyd([2,5]);
0222     
0223     
0224     <span class="keyword">if</span> debug
0225         phi = 0:.1:2*pi;
0226         
0227         plot(xx,yyd,<span class="string">'go'</span>);
0228         xxx = r(1)*cos(phi);
0229         yyy = r(1)*sin(phi);
0230         plot(xx(1)+xxx,yy(1)+yyy,<span class="string">'g:'</span>)
0231         
0232         xxx = r(2)*cos(phi);
0233         yyy = r(2)*sin(phi);
0234         plot(xx(2)+xxx,yyd(2)+yyy,<span class="string">'g:'</span>)
0235         
0236         plot( [1,ss(2)],[ymax,ymax],<span class="string">':r'</span>)
0237         plot( [1,ss(2)],[ymin,ymin],<span class="string">':r'</span>)
0238         
0239     <span class="keyword">end</span>
0240     
0241     xcen = xx;
0242     ycen = yyd;
0243     
0244     x0 = xcen(1);
0245     y0 = ycen(1);
0246     r0 = r(1);
0247     
0248     yy = max(1,round(y0-r0-2)):min(round(y0+r0+2),ss(1));
0249     xx = max(1,round(x0-r0-2)):min(round(x0+r0+2),ss(2));
0250     
0251     [X,Y] = meshgrid(xx,yy);
0252     tmp = imRot(yy,xx);
0253     
0254     R2 = (X-x0).^2 + (Y-y0).^2 - r0^2;
0255     
0256     ind_over = find( ((R2 &gt; 0).*tmp).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) &gt; 0));
0257     ind_under = find( ((R2 &lt; 0).*(tmp&lt;1)).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) &gt; 0));
0258     
0259     
0260     <span class="keyword">if</span> debug
0261         plot(X(ind_over),Y(ind_over),<span class="string">'r.'</span>);
0262         plot(X(ind_under),Y(ind_under),<span class="string">'b.'</span>);
0263     <span class="keyword">end</span>
0264     
0265     RoundIndOverTop  = sum( tmp(ind_over).*R2(ind_over))/r0^4;
0266     RoundIndUnderTop = sum( (1-tmp(ind_under)).*abs(R2(ind_under)))/r0^4;
0267     
0268     x0 = xcen(2);
0269     y0 = ycen(2);
0270     r0 = r(2);
0271     
0272     yy = max(1,round(y0-r0-2)):min(round(y0+r0+2),ss(1));
0273     xx = max(1,round(x0-r0-2)):min(round(x0+r0+2),ss(2));
0274     
0275     [X,Y] = meshgrid(xx,yy);
0276     tmp = imRot(yy,xx);
0277     
0278     R2 = (X-x0).^2 + (Y-y0).^2 - r0^2;
0279     
0280     ind_over = find( ((R2 &gt; 0).*tmp).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) &lt; 0));
0281     ind_under = find( ((R2 &lt; 0).*(tmp&lt;1)).*(d1(1,1)*(X-x0) + d1(1,2)*(Y-y0) &lt; 0));
0282     
0283     <span class="keyword">if</span> debug
0284         plot(X(ind_over),Y(ind_over),<span class="string">'r.'</span>);
0285         plot(X(ind_under),Y(ind_under),<span class="string">'b.'</span>);
0286     <span class="keyword">end</span>
0287     
0288     
0289     RoundIndOverBot  = sum( tmp(ind_over).*R2(ind_over))/r0^4;
0290     RoundIndUnderBot = sum( (1-tmp(ind_under)).*abs(R2(ind_under)))/r0^4;
0291     
0292 <span class="keyword">else</span>
0293     <span class="comment">%'fail'</span>
0294     stm1 = 0;
0295     sa1 = 0;
0296     sa2 = 0;
0297     sa3 = 0;
0298     sa4 = 0;
0299     RoundIndOverTop  = 0;
0300     RoundIndUnderTop = 0;
0301     RoundIndOverBot  = 0;
0302     RoundIndUnderBot = 0;
0303     
0304 <span class="keyword">end</span>
0305 RoundIndOver  = RoundIndOverTop  + RoundIndOverBot;
0306 RoundIndUnder = RoundIndUnderTop + RoundIndUnderBot;
0307 
0308 
0309 
0310 
0311 <span class="keyword">if</span> L1 &lt; 1
0312     L1 = 1;
0313 <span class="keyword">end</span>
0314 
0315 
0316 info = [L1, <span class="keyword">...</span>
0317     L2mean, <span class="keyword">...</span>
0318     Lneck, <span class="keyword">...</span>
0319     L2max, <span class="keyword">...</span>
0320     L2v, <span class="keyword">...</span>
0321     s1, <span class="keyword">...</span>
0322     s2, <span class="keyword">...</span>
0323     s3, <span class="keyword">...</span>
0324     RoundIndOver, <span class="keyword">...</span>
0325     RoundIndUnder, <span class="keyword">...</span>
0326     props.Area, <span class="keyword">...</span><span class="comment">.</span>
0327     stm1, <span class="keyword">...</span>
0328     sa1, <span class="keyword">...</span>
0329     sa2, <span class="keyword">...</span>
0330     sa3, <span class="keyword">...</span>
0331     sa4, <span class="keyword">...</span>
0332     1/L1, <span class="keyword">...</span>
0333     1/L2mean,<span class="keyword">...</span>
0334     minWidthEnd,<span class="keyword">...</span>
0335     sqmin,<span class="keyword">...</span>
0336     sqmax];
0337 
0338 info(isnan(info)) = 0;
0339 
0340 
0341 
0342 <span class="keyword">if</span> debug
0343     drawnow;
0344     keyboard;
0345 <span class="keyword">end</span>
0346 
0347 
0348 
0349 <span class="keyword">end</span>
0350 
0351 <a name="_sub1" href="#_subfunctions" class="code">function tmp = norm2( dd )</a>
0352 
0353 tmp = sqrt(sum(dd.*dd,2));
0354 
0355 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 23-Feb-2016 13:44:44 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>